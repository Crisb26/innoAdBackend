# Dockerfile para Railway (multi-stage optimizado)
# Etapa de build: usa Maven para compilar y empaquetar
FROM maven:3.9.4-eclipse-temurin-21 AS build
WORKDIR /workspace

# Copiamos solo pom.xml para cache de dependencias
COPY pom.xml ./
RUN mvn -B -q -DskipTests dependency:go-offline

# Ahora copiamos el código fuente
COPY src ./src

# Construimos el jar (sin tests)
RUN mvn -B -DskipTests package --no-transfer-progress \
    -Dmaven.compiler.fork=true \
    -Dmaven.compiler.meminitial=128m \
    -Dmaven.compiler.maxmem=512m

# Etapa runtime ligera
FROM eclipse-temurin:21-jre-alpine

# Instala curl solo si quieres mantener un HEALTHCHECK (opcional)
RUN apk add --no-cache curl

# Crea usuario no-root
RUN addgroup -S spring && adduser -S spring -G spring
USER spring

WORKDIR /app

# Copia el artefacto
 # Copiamos cualquier jar empacado (evita editar Dockerfile al cambiar versión)
COPY --from=build /workspace/target/innoad-backend-*.jar /app/innoad-backend.jar

# Railway asigna PORT automáticamente. Definimos fallback 8080
ENV PORT=8080 \
    SPRING_PROFILES_ACTIVE=prod \
    JAVA_OPTS=""

# Exponemos el puerto (informativo)
EXPOSE 8080

# EntryPoint ajusta server.port usando PORT de Railway
ENTRYPOINT ["sh","-c","java $JAVA_OPTS -Dserver.port=${PORT:-8080} -Dspring.profiles.active=${SPRING_PROFILES_ACTIVE:-prod} -jar /app/innoad-backend.jar"]

# Healthcheck opcional (Railway puede omitirlo, comentarlo si no lo necesitas)
HEALTHCHECK --interval=30s --timeout=5s --start-period=15s --retries=3 \
  CMD curl -f http://localhost:${PORT:-8080}/actuator/health || exit 1
